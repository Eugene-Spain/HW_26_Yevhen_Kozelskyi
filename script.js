// Task 1

const books = [
    { title: 'Гаррі Поттер', author: 'Дж.К. Ролінг' },
    { title: '1984', author: 'Джордж Орвелл' },
    { title: 'Хоббіт', author: 'Дж.Р.Р. Толкієн' }
];

let booksOfJordgeOrwell = books.filter((book) => book.author === 'Джордж Орвелл')
console.log(booksOfJordgeOrwell[0]) // ты в задании сказал первую книгу из массива, поэтому [0]. Предполагаю что можно таким же образом взять .indexOf элемента 
// у которого этот автор книги и подставить это значение в переменную после чего можно просто вызвать этот элемент массива через эту переменную. Ну либо .find :)


// Task 2

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

let newNumbers = numbers.filter((number) => {
    if (number % 2 === 0) {
        return number
    }
})
console.log(newNumbers)

// Вначале я попробывал сделать это с .map, но он постоянно создавал идентичное количество элементов, и если по условию элемент не проходил, то он запихивал в 
// массив значение undefined. Пришлось опять прибегнуть к .filter. Я где то ошибся?


// Task 3

const prices = [100, 200, 300, 400, 500];
//Всегда хотел спросить почему ты создаешь константы и пишешь их через lowercase, если говорил нам что константы обозначаются обычно капс локом ?))

// Чето я не понял почему forEach который не создает копий а перезаписывает существующий массив, показывает мне в консоли что цена меняется, 
// но массив возвращает мне старый, где данные не изменены. Видимо как то с примитивами надо по другому работать с этим методом, потому что данные внутри массивов
// как возраст userov что мі делали в уроке, он реально меняет.

// prices.forEach((price) => {
//     price *= 1.1
//     console.log(price)
//     return price
// })

// console.log(prices)

// Пришлось просто создать новый массив.
let newPrices = prices.map((price) => (price *= 1.1).toFixed(0))
console.log(newPrices)


// Task 4

const numbers2 = [45, 80, 32, 100, 105];

let isMoreThen100 = numbers2.some((number) => number > 100)
console.log(isMoreThen100)

// Task 5

const nums = [1, 2, 3, 4, 5, -6, 7];

let isAllPositive = nums.every((number) => number >= 0)
console.log(isAllPositive)

// Task 6


const sentences = ["Я люблю JavaScript", "Масиви це весело", "Програмування це круто"];

let newSentences = sentences.map((elem) => {
    
    let newArray = elem.split(" ").shift()
    return newArray
})

console.log(newSentences)
// Ты бы видел как я усердно вначале вырезал первые слова из массивов а потом внутри функции создавал новый массив и пытался запушить их в новый массив и 
// недоумевал почему я в итоге получаю массив из единичек)) Короче потом вспомнил что map возвращает 1 или -1, и понял что можно ж просто вырезать и 
// вернуть сразу в новый массив текущий результат)

// Task 7

const sentences2 = ["JavaScript цікавий", "Масиви це корисно", "Вивчайте програмування щодня"];
let count = 0
sentences2
.join(" ") // вначале первратили в стрингу
.split(" ") // затем обратно в массив но уже по слову
.forEach(() => count++) // если честно то мне кажеться ты бы поругал за этот метод для этих целей. Теоретически надо было просто сделать for i=0 и так далее
// но я когда читал документацию то запомнил (на developer.mozilla) что они там использовали этот метод с целью показать что метод пропускает пробелы 
// и не берет их в учет но также они выставили там счетчик с целью посчитать сколько слов он пройдёт, и мне показалось что это неплохой вариант для данного кейса)
console.log(count)
// console.log(sentences2) // Короче я так и не понял меняет ли .forEach массив или нет))) 


